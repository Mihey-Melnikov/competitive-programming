# Конкурентное программирование
Мельников Михей, ФТ-303

| # | Задание | Замечания | Баллы |
|--|--|--|--|
| 1 | Экспериментальным путём определить квант времени, выделяемый потоку планировщиком потоков. **Напоминание:** не забудьте привязать ваш процесс к последнему ядру и выставить процессу приоритет RealTime. Это значительно повысит точность вычислений. Но убедитесь, что процесс не будет запущен слишком долго - даже операционная система не вытесняет RealTime процессы. **Подсказка:** значение должно получаться около 32 мс (если вы не меняли настройки производительности в вашей ОС) | нет | 1 |
| 2 | Написать реализацию для интерфейса  `public interface IMultiLock { public IDisposable AcquireLock(params string[] keys);}` При вызове метода `AcquireLock` должна захватываться блокировка по набору ключей. Это значит, что если другой поток попытается захватить блокировку (используя этот же метод) и в его набор ключей будет входить хотя бы один из ранее захваченных - то этот другой поток заблокируется. Метод должен возвращать `IDisposable` объект - при вызове `Dispose()` блокировка со всех ключей из набора должна сниматься. Так же необходимо, чтобы любые два невложенных вызова `AcquireLock` не приводили к взаимоблокировке. При необходимости вы можете принимать в конструкторе `MultiLock`-а набор ключей, по которым допустима блокировка. | У тебя при ошибке могут освободиться ключи, заблокированные другим потоком. Пример: первый поток блокирует 1 2 4 и долго что-то делает, второй поток блокирует 3 4, начинает ждать 4 и мы убиваем поток. И в finally (можно было сделать catch )  освободится как 3 так и 4 | 0 |
| 3 | Написать свою реализацию класса `lock-free ConcurrentStack`. Для этого пригодятся методы класса `Interlocked`. Стек должна реализовывать интерфейс `public interface IStack<T> { void Push(T item); bool TryPop(out T item); int Count { get; } }`. Свойство `Count` должно работать за `O(1)`. На задачу отводится две недели и за неё можно получить два балла | - | 2 |
| 4 | [ File : CustomThreadPool.zip ] Ваша задача написать свой собственный `ThreadPool`, воркеры которого будут работать по алгоритму из лекции. Для того, чтобы сигнализировать потокам о появлении новых задач вам понадобится `Monitor.Pulse` и `Monitor.Wait`. Для начала вы можете попробовать реализовать простой тредпул, с одной очередью и блокировкой на ней — это будет оценено в один балл. Вам всё ещё придётся использовать `Monitor.Pulse` и `Monitor.Wait`, но не придётся реализовывать логику "воровства" из очередей воркеров. На два балла вам придётся дополнительно реализовать воровство и вам понадобится `WorkStealingQueue`. Естественно, пользоваться встроенным в .NET ThreadPool-ом нельзя, однако в коде который я вам дам будет пример реализации интерфейса, написанный поверх .NET ThreadPool-а. Так же в архиве для выполнения домашнего задания будет набор бенчмарков, которые помогут вам оценить эффективность вашего решения в сравнении с базовым.  
 | - | - |
 | 5 | [ File : DataParallelismTask.zip ] #task 5 Необходимо распараллелить программу парсящую лог-файл. В архиве с кодом приведён последовательный алгоритм парсинга. Вам необходимо написать три разных реализации интерфейса ILogParser: 1. Через PLINQ 2. Через Parallel 3. Через Thread — создание потоков вручную, ThreadPool использовать нельзя! `public interface ILogParser { string[] GetRequestedIdsFromLogFile(); }` Не забудьте распаковать логфайл в папку Files! После того как вы напишите реализации интерфейса не забудьте запустить программу и убедиться что время работы уменьшилось, а результаты не отличаются.  | - | - |
